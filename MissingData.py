#Handling Missing Data
import numpy as np
import pandas as pd
print("NONE -> Pythonic Missing Data")
vals1 =np.array([1,2,None,3])
print(vals1)
print("type ->",vals1.dtype)
print("NONE is a python object The use of Python objects in an array also means that if you perform aggregations like sum() or min() across an array with a None value, you will generally get an error ")
# print(vals1.sum())
print("\n---------------------------NaN -> Missing NUmerical Data -----------------------------------\n")
print("it is a special floating-point value recognized by all systems that use the standard IEEE floating-point representation")
vals2 = np.array([1,2,np.nan,4])
print(vals2);
print(vals2.dtype)
print("\nNaN is a bit like a data virus -> it infects any other object it touches. Regardless of the operation, the result of arithmetic with NaN will be another NaN\n")
print("1+np.nan = ",1+np.nan)
print("0*np.nan = ",0*np.nan)
print("vals2.sum(), vals2.min(), vals2.max() ->",vals2.sum(), vals2.min(), vals2.max())
print("\nNumPy does provide some special aggregations that will ignore these missing values:\n")
print("np.nansum(vals2), np.nanmin(vals2), np.nanmax(vals2) ->",np.nansum(vals2) ,np.nanmin(vals2) ,np.nanmax(vals2))
print("\n---------------------------NaN AND None In Pandas -----------------------------------\n")
print(pd.Series([1,np.nan,4,None]))
x = pd.Series(range(2),dtype=int)
print(x)
x[0] = None
print("x AFTER X[0] =  None-> \n",x)
print("\n---------------------------Operating on Null Values-----------------------------------\n")
print("isnull(): Generate a boolean mask indicating missing values")
print("notnull(): Opposite of isnull()")
print("dropna(): Return a filtered version of the data")
print("fillna(): Return a copy of the data with missing values filled or imputed")
data = pd.Series([1,"Hello",np.nan,5.4443,None])
print(data);
print("\nDetecting NULL values : \n",data.isnull())
print("\nPrinting NOT NULL values : \n",data[data.notnull()])
print("\nDropping NULL Values : \n",data.dropna())
print("\n---------------------------Dropping NUll vaues in DataFrames-----------------------------------\n")
print("\nWe cannot drop single values from a DataFrame; we can only drop full rows or full columns\n")
df = pd.DataFrame([[1,np.nan,8],
                  [5.6,8,19],
                  [None,4,66]])
print(df)
print("\nAFter using df.dropna(): \n",df.dropna())
print("\nAFter using df.dropna(axis = 'columns'): \n",df.dropna(axis="columns"))
df[3]=np.nan
print("df after adding a columns : \n",df)
print("\nhow='all', will only drop rows/columns that are all null values.The default is how='any'\n")
print("\n Using how = 'all' : \n",df.dropna(axis = 'columns',how='all'))
print("\nThe thresh parameter lets you specify a minimum number of non-null values for the row/column to be kept\n")
print("Using thresh =3: \n",df.dropna(axis='rows',thresh=3))
print("\n---------------------------Filling Null Values-----------------------------------\n")
data = pd.Series([1,3,None,9,np.nan],index=list('ABCDE'))
print(data)
print("Filling the null vales with 0 : \n",data.fillna(0))
print(" forward-fill to propagate the previous value forward: \n",data.ffill())
print("back-fill to propagate the next values backward: \n",data.bfill())
print("\nIN DATAFRAMES \n")
print("df -> \n",df)
print("After ffill : \n",df.ffill(axis=1))